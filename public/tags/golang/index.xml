<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on Dieter&#39;s blog</title>
    <link>http://localhost:1313/tags/golang/</link>
    <description>Recent content in golang on Dieter&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 02 Oct 2015 10:25:02 +0200</lastBuildDate><atom:link href="http://localhost:1313/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Interview with Matt Reiferson, creator of NSQ</title>
      <link>http://localhost:1313/posts/interview-matt-reiferson-nsq/</link>
      <pubDate>Fri, 02 Oct 2015 10:25:02 +0200</pubDate>
      
      <guid>http://localhost:1313/posts/interview-matt-reiferson-nsq/</guid>
      
      <description>I&amp;rsquo;m a fan of the NSQ message processing system written in golang. I&amp;rsquo;ve studied the code, transplanted its diskqueue code into another project, and have used NSQ by itself. The code is well thought out, organized and written.
Inspired by the book coders at work and the systems live podcast, I wanted to try something I&amp;rsquo;ve never done before: spend an hour talking to Matt Reiferson - the main author of NSQ - about software design and Go programming patterns, and post the video online for whomever might be interested.</description>
      
    </item>
    
    <item>
      <title>Transplanting Go packages for fun and profit</title>
      <link>http://localhost:1313/posts/transplanting-go-packages-for-fun-and-profit/</link>
      <pubDate>Wed, 02 Sep 2015 19:25:02 +0300</pubDate>
      
      <guid>http://localhost:1313/posts/transplanting-go-packages-for-fun-and-profit/</guid>
      
      <description>How I hunt for high quality Go code to transplant for fun and profit&amp;hellip;
This article is about learning and discussing ideas and code on a more fine grained level rather than the project/library level we&amp;rsquo;re used to.
Some anecdotes of successfully transplanting (taking components from one project and using them in another) Go code from &lt;a href=&#34;http://nsq.io&#34;&gt;NSQ&lt;/a&gt; and &lt;a href=&#34;http://bosun.org&#34;&gt;bosun&lt;/a&gt;</description>
      
    </item>
    
    <item>
      <title>Moved blog to hugo, fastly and comma</title>
      <link>http://localhost:1313/posts/moved-blog-to-hugo-fastly-comma/</link>
      <pubDate>Thu, 02 Jul 2015 16:35:02 -0700</pubDate>
      
      <guid>http://localhost:1313/posts/moved-blog-to-hugo-fastly-comma/</guid>
      
      <description>&lt;ul&gt;
&lt;li&gt;I noticed what a disservice I was doing my readers when I started monitoring my site using &lt;a href=&#34;http://www.raintank.io/litmus/&#34;&gt;litmus&lt;/a&gt;.
A dynamic website in python on a cheap linode&amp;hellip; What do you expect?  So I now serve through &lt;a href=&#34;https://www.fastly.com/&#34;&gt;fastly&lt;/a&gt; and use a static site generator.&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>A real whisper-to-InfluxDB program.</title>
      <link>http://localhost:1313/posts/a-real-whisper-to-influxdb-program/</link>
      <pubDate>Tue, 30 Sep 2014 08:37:48 -0400</pubDate>
      
      <guid>http://localhost:1313/posts/a-real-whisper-to-influxdb-program/</guid>
      
      <description>The whisper-to-influxdb migration script I posted earlier is pretty bad. A shell script, without concurrency, and an undiagnosed performance issue. I hinted that one could write a Go program using the unofficial whisper-go bindings and the influxdb Go client library. That&#39;s what I did now, it&#39;s at github.com/vimeo/whisper-to-influxdb. It uses configurable amounts of workers for both whisper fetches and InfluxDB commits, but it&#39;s still a bit naive in the sense that it commits to InfluxDB one serie at a time, irrespective of how many records are in it.</description>
      
    </item>
    
    <item>
      <title>InfluxDB as a graphite backend, part 2</title>
      <link>http://localhost:1313/posts/influxdb-as-graphite-backend-part2/</link>
      <pubDate>Wed, 24 Sep 2014 07:56:01 -0400</pubDate>
      
      <guid>http://localhost:1313/posts/influxdb-as-graphite-backend-part2/</guid>
      
      <description>&lt;br&gt;
&lt;br/&gt;Updated oct 1, 2014 with a new &lt;i&gt;Disk space efficiency&lt;/i&gt; section which fixes some mistakes and adds more clarity.
&lt;br/&gt;

&lt;p&gt;
The &lt;i&gt;Graphite + InfluxDB&lt;/i&gt; series continues.
&lt;ul&gt;
&lt;li&gt;In part 1, &lt;a href=&#34;http://localhost:1313/on-graphite-whisper-and-influxdb.html&#34;&gt;&#34;On Graphite, Whisper and InfluxDB&#34;&lt;/a&gt; I described the problems of Graphite&#39;s whisper and ceres, why I disagree with common graphite clustering advice as being the right path forward, what a great timeseries storage system would mean to me, why InfluxDB - despite being the youngest project - is my main interest right now, and introduced my approach for combining both and leveraging their respective strengths: InfluxDB as an ingestion and storage backend (and at some point, realtime processing and pub-sub) and graphite for its renown data processing-on-retrieval functionality.
Furthermore, I introduced some tooling: &lt;a href=&#34;https://github.com/graphite-ng/carbon-relay-ng&#34;&gt;carbon-relay-ng&lt;/a&gt; to easily route streams of carbon data (metrics datapoints) to storage backends, allowing me to send production data to Carbon+whisper as well as InfluxDB in parallel, &lt;a href=&#34;https://github.com/brutasse/graphite-api&#34;&gt;graphite-api&lt;/a&gt;, the simpler Graphite API server, with &lt;a href=&#34;https://github.com/vimeo/graphite-influxdb&#34;&gt;graphite-influxdb&lt;/a&gt; to fetch data from InfluxDB.
&lt;/li&gt;
&lt;li&gt;Not Graphite related, but I wrote &lt;a href=&#34;https://github.com/Dieterbe/influx-cli&#34;&gt;influx-cli&lt;/a&gt; which I introduced &lt;a href=&#34;http://localhost:1313/influx-cli_a_commandline_interface_to_influxdb.html&#34;&gt;here&lt;/a&gt;.  It allows to easily interface with InfluxDB and measure the duration of operations, which will become useful for this article.&lt;/li&gt;
&lt;li&gt;In the &lt;a href=&#34;graphite-influxdb-intermezzo-migrating-old-data-and-a-more-powerful-carbon-relay.html&#34;&gt;Graphite &amp;amp; Influxdb intermezzo&lt;/a&gt; I shared a script to import whisper data into InfluxDB and noted some write performance issues I was seeing, but the better part of the article described the various improvements done to &lt;a href=&#34;https://github.com/graphite-ng/carbon-relay-ng&#34;&gt;carbon-relay-ng&lt;/a&gt;, which is becoming an increasingly versatile and useful tool.&lt;/li&gt;
&lt;li&gt;In &lt;a href=&#34;http://localhost:1313/using-influxdb-as-graphite-backend-part2.html&#34;&gt;part 2&lt;/a&gt;, which you are reading now, I&#39;m going to describe recent progress, share more info about my setup, testing results, state of affairs, and ideas for future work&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Graphite &amp; Influxdb intermezzo: migrating old data and a more powerful carbon relay</title>
      <link>http://localhost:1313/posts/graphite-influxdb-intermezzo-migrating-old-data-and-a-more-powerful-carbon-relay/</link>
      <pubDate>Sat, 20 Sep 2014 15:18:32 -0400</pubDate>
      
      <guid>http://localhost:1313/posts/graphite-influxdb-intermezzo-migrating-old-data-and-a-more-powerful-carbon-relay/</guid>
      
      <description>Migrating data from whisper into InfluxDB &#34;How do i migrate whisper data to influxdb&#34; is a question that comes up regularly, and I&#39;ve always replied it should be easy to write a tool to do this. I personally had no need for this, until a recent small influxdb outage where I wanted to sync data from our backup server (running graphite + whisper) to influxdb, so I wrote a script: #!</description>
      
    </item>
    
    <item>
      <title>Influx-cli: a commandline interface to Influxdb.</title>
      <link>http://localhost:1313/posts/influx-cli_a_commandline_interface_to_influxdb/</link>
      <pubDate>Mon, 08 Sep 2014 08:36:36 -0400</pubDate>
      
      <guid>http://localhost:1313/posts/influx-cli_a_commandline_interface_to_influxdb/</guid>
      
      <description>&lt;p&gt;
Time for another side project:
&lt;a href=&#34;https://github.com/Dieterbe/influx-cli&#34;&gt;influx-cli&lt;/a&gt;,
a commandline interface to influxdb.
&lt;br/&gt;
Nothing groundbreaking, and it behaves pretty much as you would expect if you&#39;ve ever used
the mysql, pgsql, vsql, etc tools before.
&lt;br/&gt;But I did want to highlight a few interesting features.
&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Beautiful Go patterns for concurrent access to shared resources and coordinating responses</title>
      <link>http://localhost:1313/posts/beautiful_go_patterns_for_concurrent_access_to_shared_resources_and_coordinating_responses/</link>
      <pubDate>Sat, 26 Jul 2014 13:22:32 -0400</pubDate>
      
      <guid>http://localhost:1313/posts/beautiful_go_patterns_for_concurrent_access_to_shared_resources_and_coordinating_responses/</guid>
      
      <description>&lt;p&gt;It&amp;rsquo;s a pretty common thing in backend go programs to have multiple coroutines concurrently needing to modify a shared resource,
and needing a response that tells them whether the operation succeeded and/or other auxiliary information.
Something centralized manages the shared state, the changes to it and the responses.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>On Graphite, Whisper and InfluxDB</title>
      <link>http://localhost:1313/posts/on-graphite-whisper-and-influxdb/</link>
      <pubDate>Sun, 18 May 2014 13:22:32 -0400</pubDate>
      
      <guid>http://localhost:1313/posts/on-graphite-whisper-and-influxdb/</guid>
      
      <description>&lt;h4&gt;Graphite, and the storage Achilles heel&lt;/h4&gt;

Graphite is a neat timeseries metrics storage system that comes with a powerful querying api, mainly due to the whole bunch of &lt;a href=&#34;http://graphite.readthedocs.org/en/latest/functions.html&#34;&gt;available processing functions&lt;/a&gt;.
&lt;br/&gt;For medium to large setups, the storage aspect quickly becomes a pain point.  Whisper, the default graphite storage format, is a simple storage format, using one file per metric (timeseries).
</description>
      
    </item>
    
    <item>
      <title>Pixie: simple photo management using directory layouts and tags.</title>
      <link>http://localhost:1313/posts/pixie/</link>
      <pubDate>Mon, 30 Dec 2013 14:46:32 -0400</pubDate>
      
      <guid>http://localhost:1313/posts/pixie/</guid>
      
      <description>So you have a few devices with pictures, and maybe some additional pictures your friends sent you.  You have a lot of pictures of the same thing and probably too high of a resolution.  Some may require some editing.  How do you easily create photo albums out of this mess?  And how do you do it in a way
that keeps a simple and elegant, yet flexible file/directory layout for portability and simplicity?
</description>
      
    </item>
    
    <item>
      <title>Graphite-ng: A next-gen graphite server in Go.</title>
      <link>http://localhost:1313/posts/graphite-ng_a-next-gen-graphite-server-in-go/</link>
      <pubDate>Sat, 07 Sep 2013 20:54:20 -0400</pubDate>
      
      <guid>http://localhost:1313/posts/graphite-ng_a-next-gen-graphite-server-in-go/</guid>
      
      <description>&lt;p&gt;
I&#39;ve been a &lt;a href=&#34;https://github.com/graphite-project/&#34;&gt;graphite&lt;/a&gt; contributor for a while (and still am).  It&#39;s a &lt;i&gt;great&lt;/i&gt; tool for timeseries metrics.
Two weeks ago I started working on &lt;a href=&#34;https://github.com/graphite-ng/graphite-ng&#34;&gt;Graphite-ng&lt;/a&gt;:
it&#39;s somewhere between an early clone/rewrite, a redesign, and an experiment playground, written in &lt;a href=&#34;http://golang.org&#34;&gt;Golang&lt;/a&gt;.
The focus of my work so far is the API web server, which is a functioning prototype, it answers requests like&lt;/p&gt;
{{&lt; highlight &#34;javascript&#34; &#34;style=default&#34; &gt;}}
/render/?target=sum(scale(stats.web2,5.12),derivative(stats.web2))
{{&lt; /highlight &gt;}}
&lt;p&gt;
I.e. it lets you retrieve your timeseries, processed by function pipelines which are setup on the fly based on a spec in your http/rest arguments.
Currently it only fetches metrics from text files but I&#39;m working on decent metrics storage as well.
&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
